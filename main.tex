% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}


\NewBibliographyString{langjapanese}
\NewBibliographyString{fromjapanese}

\begin{document}

\addsec{Постановка задачи}
\begin{enumerate}
  \item Анализ возможных подходов к реализации подсветки вывода
  \item Изучение программной структуры GHCi
  \item Программная реализация цветовой поддержки вывода интерпретатора GHCi
\end{enumerate}  

\newpage
  
\tableofcontents

\newpage

\Intro

GHC - один из наиболее развитых на сегодняшний день компиляторов функционального языка Haskell. В состав компилятора входит интерпретирующая интерактивная среда GHCi. GHCi используется для отображения результатов вызовов функций, отладочной информации, вывода типов и сортов функций.

Во многих интерактивных средах разработки поддерживается цветовое выделение  ключевых слов, констант и выражений в программном выводе. Такая возможность широко используется для обеспечения наглядности и удобности чтения и анализа программного вывода.

В настоящее время в состав GHC не входит встроенных средств для окраски выводимого текста. Существуют программы, позволяющие частично решить данную задачу. В данной работе рассматривается программная реализация, обеспечивающая цветовую поддержку консольного вывода в интерпретаторе, а также анализируется программная составляющая GHC с точки зрения решения задачи цветовой поддержки вывода в консоль.

\section{Решение на основе внешней обработки вывода}
\subsection{Алгоритм решения}
Одним из возможных решений является внешняя обработка выводимого интерпретатором GHCi текстового результата. Этот вариант удобен тем, что для его реализации нет необходимости изменять исходный код интерпретатора.

Обработка вывода интерпретатора GHCi должна работать по данному алгоритму:
\begin{enumerate}
  \item Внешняя программа-обработчик принимает пользовательский ввод;
  \item Этот пользовательский ввод передаётся в интерпретатор GHCi;
  \item Программа-обработчик перехватывает вывод результата GHCi;
  \item Этот результат обрабатывается и возвращается пользователю.
\end{enumerate}

Основной проблемой данного алгоритма является передача команд интерпретатору для обработки. GHC не предоставляет функционала для выполнения команд, подаваемых из внешней программы. Существует возможность построчного выполнения команд путём запуска компилятора GHC в интерактивном режиме со строкой-командой в параметре, однако в случае такого подхода теряется контекст выполнения, такой как значения вычисленных переменных.

\subsection{Программная реализация}
В рамках решения задачи цветовой поддержки вывода, была создана программная реализация, поддерживающая указанный алгоритм. Эта реализация является обёрткой над GHCi. Она представляет пользователю возможность консольного ввода команд, после чего эти команды передаются интерпретатору для вычисления. Результат вычислений обрабатывается во внешней программе, после чего выводится в консоль.

Проблема передачи выражений для вычисления компилятором GHC была решена использованием библиотеки ghcid. Данная библиотека позволяет запустить и использовать установленный в системе интерпретатор GHCi в фоновом режиме с полной поддержкой всего функционала. Для обращения к нему она предоставляет собственный API [1].

\newpage

\begin{lstlisting}[language=Haskell, caption=Пример выполнения входной строки с помощью ghcid]
(ghci, _) <- startGhci "ghci" (Just ".") True
let executeStatement = exec ghci
input <- getLine
result <- executeStatement input
\end{lstlisting}

В этом примере вводимая команда содержится в переменной input. Функция executeStatement передаёт введённую команду запущенному в фоне ghci и возвращает результат. Результат возвращается как набор строк в монаде IO и извлекается в переменную result.

После получения результатов из GHCi, набор строк передаётся парсеру. Парсер выделяет из строки элементы, которым необходимо добавить окраску. К данным элементам он добавляет информацию о типе подстроки. Информация о типе используется в дальнейшем для выбора параметров окраски.

\begin{lstlisting}[language=Haskell]
data SDoc next =
  SEmpty
  | SText String (SDoc next)
  | SToken Token (SDoc next)
\end{lstlisting}

При создании элементов типа SDoc может возникнуть проблема изменения типа выражения. Параметр next типа SDoc используется как неподвижная точка. Его использование позволяет сохранить исходный тип.

SToken содержит некоторое выражение, которое необходимо окрасить и дополнительную информацию о типе выражения. Этот тип используется в дальнейшем для окраски выделенной подстроки. Если же подстрока не распознаётся, то она заносится в SText, и в дальнейшем никак дополнительно не обрабатывается.

\begin{lstlisting}[language=Haskell]
data Token =
  Arrow            String
  | Bracket        String
  | Digit          String
  | Typeclass      String
  | Type           String
  | CompileInfo    String 
  | Keyword	   String
\end{lstlisting}

В листинге представлена функция-парсер, генерирующая из строки выражение типа SDoc.

\begin{lstlisting}[language=Haskell, caption = Функция парсинга выражения]
parseExpression :: String -> SDoc next
parseExpression "" = SEmpty
parseExpression str
  | isStartsWithArrow str
    = SToken (Arrow (extractArrow str)) (parseExpression . dropArrow $ str)
  | isStartsWithBracket str
    = SToken (Bracket (extractBracket str)) (parseExpression . dropBracket $ str)
  | isStartsWithTypeclass str
    = SToken (Typeclass (extractTypeclass str)) (parseExpression . dropTypeclass $ str)
  | isStartsWithType str
    = SToken (Type (extractType str)) (parseExpression . dropType $ str)
  | isStartsWithInfo str
    = SToken (CompileInfo (extractCInfo str)) (parseExpression . dropCInfo $ str)
  | isStartsWithKeyword str
    = SToken (Keyword (extractKeyword str)) (parseExpression . dropKeyword $ str)
\end{lstlisting}

После построения выражения типа SDoc, функция-визитор осуществляет проход по нему. Подвыражения типа SToken окрашиваются и преобразуются в тип SText с удалением информации о содержащемся типе. Окрашивание происходит добавлением ANSI символов. Полученный список строк конкатенируется и выводится пользователю.

\begin{lstlisting}[language=Haskell, caption=Окрашивание выражения]
colorizeToken :: Token -> String

colorize :: SDoc next -> SDoc next
colorize SEmpty           = SEmpty
colorize (SToken token n) = SText (colorizeToken token) (colorize n)
colorize (SText str n)    = SText str (colorize n)
\end{lstlisting}

Функция добавления ANSI символов colorizeToken имеет следующий вид.
\begin{lstlisting}[language=Haskell]
colorizeToken :: SColor -> String -> String
colorizeToken col str = (show col) ++ str ++ (show getDefaultColor)
\end{lstlisting}

На скриншоте ниже представлен скриншот с примером работы полученной реализации. Запуск проводился на GHC 7.8.4. Продемонстрирована подсветка текстовых и численных констант, а также встроенных в GHC классов и классов типов.

\centerline{\includegraphics[scale=0.75]{img/example.png}}

\subsection{Сравнение реализаций}
В рамках сравнения реализаций, рассмотрим скрипт ghci-color, используемый для задачи окрашивания вывода [2].

Скрипт ghci-color также использует внешнюю обработку текстового вывода. Это достигается использованием потокового текстового редактора sed. Sed получает входной поток, преобразует каждую строку строку, согласно записанным в скрипт правилам, а затем выводит результат в выходной поток. Правила в скрипте основываются на регулярных выражениях. К подстроке, распознающейся регулярным выражением, добавляются ANSI символы.

Несмотря на схожий принцип действия, данные реализации имеют различия. Для использования ghci-color необходимо устанавливать текстовый редактор sed. Кроме того, в текущей реализации sed отсутствует подсветка типов и классов типов. Масштабирование скрипта с правилами затруднено тем, что для каждого нового элемента необходимо добавлять новое правило на основе регулярных выражений.

\subsection{Анализ полученных результатов}
Полученная реализация решает поставленную задачу по окраске вывода интерпретатора GHCi, однако обладает рядом недостатков:

\begin{enumerate}
\item Программа может обеспечить корректную окраску только для стандартных имён, так как не обладает информацией об определенных пользователем типах, классах типов и переменных
\item В некоторых ОС необходимы дополнительные действия по обеспечению корректной работы подсветки на основе ANSI символов
\item Со стороны пользователя требуются дополнительные действия для запуска данной программы, и её дальнейшего использования
\end{enumerate}

Таким образом, полученная программа решает поставленную задачу по окраске вывода GHCi. Однако, с учётом указанных выше недостатков, решение можно считать частичным.

\section{Система печати в GHCi}
Система вывода компилятора GHC основана на принципе структурной печати. Структурная печать используется для программного комбинирования, форматирования и вывода текста [3].

Основном примитивом в модели структурной печати является тип Doc, находящийся в модуле Pretty.
\begin{lstlisting}[language=Haskell]
data Doc
 = Empty
 | NilAbove Doc
 | Nest FastInt Doc
 | Union Doc Doc
 | ...
\end{lstlisting}

Тип Doc представляет набор текстовых элементов. Для данных текстовых элементов определены различные операции конкатенации, форматирования и выравнивания.

Тип SDoc является для типа Doc, он находится в модуле Outputable. Тип SDoc содержит дополнительную информацию для обработки текстового элемента, содержащегося в Doc.
\begin{lstlisting}[language=Haskell]
type SDoc = PprStyle -> Doc

data PprStyle
  = PprUser PrintUnqualified Depth
  | PprCode CodeStyle
  | PprDump
  | PprDebug
\end{lstlisting}

PprStyle содержит перечисление вариантов вывода текста. Он используется, чтобы указать цель вывода текста: пользовательский вывод, отладка или печать самой программы.

В языке Haskell класс типов содержит сигнатуры функций, применяемых к значениям некого типа. [4] Класс типов Outputable предоставляет интерфейс для типов, поддерживающих функцию структурной печати. Для большинства встроенных типов в Haskell имеется поддержка Outputable.

\begin{lstlisting}[language=Haskell]
class Outputable a where
	ppr :: a -> SDoc
\end{lstlisting}

Класс типов Outputable имеет одну функцию ppr, которая переводит выражение исходного типа в соответствующее ему выражение типа SDoc. Например, функция ppr для типа Int имеет следующий вид:

\begin{lstlisting}[language=Haskell]
instance Outputable Int where
    ppr n = int n

int n = \ _ -> (text $ show n)

\end{lstlisting}

Для конечного преобразования элементов типа Doc в строки и их вывода, используется функция рендеринга текста, входящая в состав модуль Pretty.

\begin{lstlisting}[language=Haskell, caption=Типовая аннотация к функции рендеринга текста]
render :: Handle -> SDoc -> IO ()
\end{lstlisting}

Текущая реализация класса типов Outputable и типа SDoc не поддерживает указание цвета данного элемента, поэтому для решения задачи по добавлению окраски вывода необходимо изменить их реализации.

\section{Необходимые изменения в модуле Outputable}

Для получения списка необходимых изменений в системе вывода GHC, была разработана модель вывода, действующая аналогично системе вывода в GHC. Эта модель поддерживала ограниченное количество типов и операций с элементами. На основе этой модели были проанализированы и получены изменения, которые необходимы в GHC для обеспечения подсветки вывода.

Для внедрения данных изменений в компилятор GHC, необходимо изменение большого количество стороненно кода, поэтому предлагаемые изменения рассматриваются в рамках созданной модели.

\subsection{Изменения в модуле Outputable}

В текущей реализации тип SDoc содержит информацию только о формате вывода. Тип-перечисление PprStyle в SDoc необходимо заменить на тип SDocStyle, который будет содержать информацию о формате вывода и о цвете данного текста. Это добавление указывать текст данного элемента в момент его создания.

\begin{lstlisting}[language=Haskell, caption=Дополненная реализация типа SDoc]
type SDoc = SDocStyle -> Doc
data SDocStyle = {
    pprStyle :: PprStyle,
    pprColor :: PprColor
}
type PprColor =
   CDefault
 | CRed
 | CBlue
 | ...
\end{lstlisting}

Примером работы с обёрткой при изменении цвета, является функция colorize. Ввиду неизменяемости данных в языке Haskell, функция colorize изменяет информацию о цвете путем создания нового элемента типа SDoc, содержащего новый цвет.

\begin{lstlisting}[language=Haskell, caption=Пример функции окраски]
colorize :: PprColor -> SDoc -> SDoc
colorize newPprColor sDoc = (newSDocStyle -> docContent)
  where 
    docContent = sDoc createEmptyStyle
    sDocStyle = pprStyle sDoc  
    newSDocStyle = SDocStyle { 
      pprStyle = pprStyle sDocStyle, 
      pprColor = newPprColor 
    }
\end{lstlisting}

Для поддержки цветового выделения всеми типами, необходим новый класс типов ColorOutputable. Чтобы поддерживать ColorOutputable, тип должен иметь поддержку Outputable. Для полной поддержки введённых изменений, необходимо полностью заменить Outputable на ColorOutputable во всех участках кода, где создаются элементы типа SDoc. Также ColorOutputable должен поддерживать все операции комбинирования, используемые в структурной печати.

\begin{lstlisting}[language=Haskell, caption=Класс типов ColorOutputable]
class Outputable a => ColorOutputable a where
  cppr :: a -> SDoc
\end{lstlisting}

Для получения соответствующего элемента типа SDoc на основании выражения исходного типа, функция cppr использует функцию ppr. После чего к выражению добавляется информация о цвете. Если данный элемент не требует окрашивания, то его значением цвета указывается CDefault. При дальнейшей генерации выводимого текста, этот элемент дополнительно не обрабатывается и выводится в стандартном цвете.

\begin{lstlisting}[language=Haskell, caption=Пример реализации ColorOutputable для типа Int]
instance ColorOutputable Int where
  cppr n = (colorize CBlue) . ppr $ n
\end{lstlisting}

Полученная информация о цвете используется при получении строкового представления из элементов типа SDoc. Функция colorizeDoc получает окрашенный вариант элемента типа Doc.

\begin{lstlisting}[language=Haskell]
colorizeDoc :: String -> String -> Doc -> Doc
colorizeDoc newColorStr defColorStr doc = (ptext newColorStr) <+> doc <+> (ptext defColorStr)
\end{lstlisting}


\subsection{Примеры с внедренными изменениями}

В качестве примеров рассмотрим несколько функций, аналоги которых были реализованы в модели.

Функция mkExpectedActualMsg, входящая в модуль TcErrors генерирует сообщение о несоответствии типов. Этот поддокумент состоит из ожидаемого типа и полученного типа.

\begin{lstlisting}[language=Haskell]
mkExpectedActualMsg :: Type -> Type -> SDoc
mkExpectedActualMsg exp_ty act_ty
  = vcat [ ptext (text "Expected type:") <+> ppr exp_ty
         , ptext (text "  Actual type:") <+> ppr act_ty ]
\end{lstlisting}

В данной функции возможно добавить цветовое выделение текстовых констант и типов. Для окрашивания типов используется функция cppr, входящая в класс типов ColorOutputable. Тип String не имеет реализации для Outputable, поэтому для него нельзя реализовать ColorOutputable. В данном примере окраска строковых констант выполняется вручную.

\begin{lstlisting}[language=Haskell, caption=Реализация функции с изменениями]
mkExpectedActualMsg :: Type -> Type -> SDoc
mkExpectedActualMsg exp_ty act_ty
  = vcat [ colorize cRed $ ptext (text "Expected type:") <+> cppr exp_ty
         , colorize cRed $ ptext (text "  Actual type:") <+> cppr act_ty ]
\end{lstlisting}

Функция srcParseErr используется в парсере компилятора GHC. Она генерирует сообщение об ошибки в пользовательском вводе.

\begin{lstlisting}[language=Haskell]
srcParseErr options buf len = if null token
         then ptext (text "parse error (possibly incorrect indentation or mismatched brackets)")
         else ptext (text "parse error on input" <+> quotes (text token))
  where token = ...    
\end{lstlisting}

В данном примере добавляется цветовое выделение к сообщению об ошибке и неправильно введённому значению.

\begin{lstlisting}[language=Haskell]
srcParseErr options buf len = if null token
         then parseErrorMsg <+> ptext (text "(possibly incorrect indentation or mismatched brackets)")
         else parseErrorMsg <+> ptext (text " on input" <+> quotes (text token))
  where 
    parseErrorMsg = colorize cRed $ ptext (text "parse error")
    token = ...    
\end{lstlisting}

Данные примеры иллюстрируют, что представленных выше изменений достаточно для цветовой поддержки вывода консоли интерпретатора GHCi.

\Conc
В результате работы была создана программная реализация, решающая поставленную задачу. Эта реализация имеет ряд указанных недостатков.

Была проанализирована реализация вывода, используемая в GHC. На основе этой реализации был создан модуль, действующий аналогично системе вывода GHC. По данной модели были получены изменения, которые необходимо внести в систему печати GHC для того, чтоб реализовать цветовую поддержку вывода.

\addsec{Список литературы}
\begin{enumerate}
  \item Библиотека ghcid. -- URL: https://github.com/ndmitchell/ghcid (дата обр. 05.05.2016)
  \item Скрипт ghci-color. -- URL: https://github.com/rhysd/ghci-color (дата обр. 06.05.2016)
  \item Документация по компилятору GHC -- URL: https://downloads.haskell.org/~ghc/7.10.2/docs/html/ (дата обр. 30.04.2016)
  \item Bryan O'Sullivan -- Real World Haskell. -- URL: http://book.realworldhaskell.org/ (дата обр 25.04.2016)
\end{enumerate}

\end{document}